# 内部类语法糖

内部类相比顶层类来说能够访问外部类中的更多属性，如私有成员，但是这些类在生成Class文件的过程中都将作为一个单独的类而存在，这样就无法访问外部类的一些成员，所以内部类也是语法糖，需要经过解语法糖后才能作为一个单独的类存在。举个例子如下： 

【实例15\-14】

---

```java
class Outer {
    private int a = 1;
    class Inner {
        int b = a;
    }
}
```

---

实例15\-14的Outer类经过解语法糖后变为如下形式： 

---

```java
class Outer {    
    /*synthetic*/ static int access$000(Outer x0) {
        return x0.a;
    }
    private int a = 1;
}
```

---

实例15\-14的Inner类经过解语法糖后变为如下形式： 

---

```java
class Outer$Inner {
    /*synthetic*/ final Outer this$0;    
    Outer$Inner(/*synthetic*/ final Outer this$0) {
        this.this$0 = this$0;
        super();
    }
    int b = Outer.access$000(this$0);
}
```

---

可以看出，Javac对内部类Inner解语法糖后做了一些特殊处理，在Outer\$Inner中访问外部类的私有变量a更改为通过调用Outer.access\$000\(\)方法访问，后面我们将方法名以“access\$”字符串开头的方法都称为获取方法。其实不光是私有成员变量，对于私有方法及某些特殊情况下由protected修饰的成员，都需要通过获取方法来访问。 

### 15.4.1　调用私有构造方法 

任何Java嵌套类通过Javac编译后都会生成一个单独的Class文件，所以如果嵌套类调用了外部类的私有构造方法，那么解语法糖时就需要做一些特殊的处理，否则将访问不到调用的私有构造方法。举个例子如下： 

【实例15\-15】

---

```java
class Outer {
    private Outer() { }
    class Inner {
        public void md() {
            Outer o = new Outer();
        }
    }
}
```

---

经过Javac编译后生成了3个Class文件，分别为Outer.class、Outer\$Inner.class和Outer$1.class。Outer.class是Outer类生成的Class文件，Outer\$Inner.class是Inner生成的Class文件，Outer\$1.class是为了避免调用私有构造方法产生冲突而由Javac生成的一个空实现的类。3个文件中的内容可以等价看作是如下3个类生成的Class文件： 

---

```java
class Outer$Inner{
    public void md() {
        Outer o = new Outer(null);
    }
}
/*synthetic*/ class Outer$1 { }
class Outer {    
    /*synthetic*/ Outer(chapter15.Outer$1 x0) {
        this();
    }   
    private Outer() {
        super();
    }
}
```

---

在Outer\$Inner类中调用了一个合成的、形式参数类型为Outer\$1的非私有构造方法，这个构造方法又调用了Outer类的私有构造方法，内部类通过这样的方式访问了外部类的私有构造方法。之所以要合成一个参数类型为Outer\$1的构造方法，是为了避免与现有构造方法冲突，Outer\$1类型是Javac在编译时使用的类型，不可能被代码编写者使用。 

在创建类的对象时，通常会调用这个类的构造方法，所以需要在visitNewClass\(\)方法中对调用的私有构造方法解语法糖，相关的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
Symbol constructor = accessConstructor(_, tree.constructor);
if (constructor != tree.constructor) {
    tree.args = tree.args.append(makeNull());
    tree.constructor = constructor;
}
```

---

首先调用accessConstructor\(\)方法获取constructor，这个对象对于实例15\-15来说就是Outer类中的合成构造方法。如果constructor与原来的tree.constructor不一样，说明这是一个合成的构造方法，需要将之前的调用私有构造方法改为调用合成的构造方法，在调用时向实际参数列表末尾追加一个null参数，然后将tree.constructor更新为constructor。对于实例15\-15来说，就是将Outer$Inner类中创建Outer对象的表达式new Outer\(\)改为new Outer\(null\)的形式。 

accessConstructor\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
Symbol accessConstructor(_, Symbol constr) {
    if (needsPrivateAccess(constr)) {
        ClassSymbol accOwner = constr.owner.enclClass();
        MethodSymbol aconstr = accessConstrs.get(constr);
        if (aconstr == null) {
            List<Type> argtypes = constr.type.getParameterTypes();
                       aconstr = new MethodSymbol(SYNTHETIC,names.init,
                       new MethodType( argtypes.append(accessConstructorTag().
erasure(types)),
                       constr.type.getReturnType(),constr.type.getThrownTypes(),
                       syms.methodClass),accOwner);
            enterSynthetic(_, aconstr, accOwner.members());
            accessConstrs.put(constr, aconstr);
            accessed.append(constr);
        }
        return aconstr;
    } else {
        return constr;
    }
}
```

---

调用needsPrivateAccess\(\)方法判断是否需要处理对私有构造方法的调用，如果该方法返回true，会合成新的构造方法aconstr，调用enterSynthetic\(\)方法将aconstr填充到accOwner.members\_field中，也就是说合成的构造方法会添加到accOwner中。 

needsPrivateAccess\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
boolean needsPrivateAccess(Symbol sym) {
    if ((sym.flags() & PRIVATE) == 0 || sym.owner == currentClass) {
        return false;
    } else if (sym.name == names.init && (sym.owner.owner.kind & (VAR |
MTH)) != 0) {
        sym.flags_field &= ~PRIVATE;
        return false;
    } else {
        return true;
    }
}
```

---

如果为非私有成员或者在当前类中使用私有成员，needsPrivateAccess\(\)方法返回false，表示不需要添加获取方法。如果有调用本地类的私有构造方法，则直接去掉构造方法的private修饰符，举个例子如下： 

【实例15\-16】

---

```java
class Outer {
    public void md() {
        class Local{
            private Local(){}
        }
        new Local();
    }
}
```

---

由于本地类Local中有个私有构造方法，所以如果单独作为一个类时，在md\(\)方法中创建Local对象将无法访问私有构造方法。这里会将private修饰符去掉，这样就能正常访问Local类的私有构造方法了。 

needsPrivateAccess\(\)方法在合成新的构造方法时，通过accessConstrs判断之前是否已经合成过此私有构造方法对应的合成构造方法，如果有，就不需要再次合成，如果没有，就会创建一个新的构造方法aconstr。accessConstrs是一个Map\<Symbol,MethodSymbol\>对象，保存了原构造方法到新构造方法的映射。 

由于更新的是标注语法树，所以合成构造方法也一定要标注对应的符号和类型。在创建MethodType对象时，为形式参数列表argtypes中追加了一个类型，首先通过调用accessConstructorTag\(\)方法创建一个ClassSymbol对象，然后调用erasure\(\)方法获取对应的类型。accessConstructorTag\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
/** Return an anonymous class nested in this toplevel class.
 */
ClassSymbol accessConstructorTag() {
    ClassSymbol topClass = currentClass.outermostClass();
    Name flatname = names.fromString("" + topClass.getQualifiedName() +
                                     target.syntheticNameChar() + "1");
    ClassSymbol ctag = chk.compiled.get(flatname);
    if (ctag == null)
        ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass);
    return ctag;
}
```

---

对于实例15\-15来说，调用当前方法可以获取到一个Outer$1类型，然后追加到形式参数列表的末尾。 

accessConstructor\(\)方法通过accessConstrs保存私有构造方法到合成构造方法的对应关系，这样下次需要为私有构造方法合成构造方法时就可以重用这个已经合成的构造方法。另外，私有构造方法还会保存到类型为ListBuffer\<Symbol\>的accessed变量中，后序将调用translateTopLevelClass\(\)方法循环这个列表中的值，然后通过accessConstrs取出所有合成的构造方法，然后合成JCMethodDecl树节点并添加到标注语法树上。translateTopLevelClass\(\)方法中的相关实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
for (List<Symbol> l = accessed.toList(); l.nonEmpty(); l = l.tail)
    makeAccessible(l.head);
```

---

调用的makeAccessible\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
void makeAccessible(Symbol sym) {
    JCClassDecl cdef = classDef(sym.owner.enclClass());
    if (sym.name == names.init) {
        cdef.defs = cdef.defs.prepend(accessConstructorDef(_, sym, accessConstrs.
get(sym)));
    } 
}
```

---

当sym为构造方法时，调用accessConstructorDef\(\)方法合成新的构造方法对应的语法树节点，然后追加到cdef.defs中。accessConstructorDef\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
JCTree accessConstructorDef(_, Symbol constr, MethodSymbol accessor) {
    JCMethodDecl md = make.MethodDef(accessor,accessor.externalType(types),
null);
    JCIdent callee = make.Ident(names._this);
    callee.sym = constr;
    callee.type = constr.type;
    md.body = vmake.Block(0, List.<JCStatement>of(
            make.Call(make.App(callee,make.Idents(md.params.reverse().
ail.reverse())))));
    return md;
}
```

---

根据一定的规则创建一个新的JCMethodDecl语法树节点，然后标注相关的语法树节点。调用accessor.externalType\(\)方法可以获取构造方法的类型，由于篇幅有限，这里不再介绍。 

### 15.4.2　引用成员 

访问外部类的一些成员在解语法糖阶段需要通过调用获取方法的方式来访问，对于成员类型来说，如果有protected或private修饰，则最终作为一个单独的顶层类时会去掉权限访问符，去掉后不会影响对此类的访问，所以不需要特殊处理；对于方法和成员变量来说，可以通过access\(\)方法判断是否需要为成员添加获取方法，相关的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
boolean protAccess = refSuper && !needsPrivateAccess(sym) || needsProtected
Access(sym, tree);
boolean accReq = protAccess || needsPrivateAccess(sym);
```

---

其中，sym就是被引用的成员符号。当accReq的值为true时就会添加对应的获取方法。从以上的实现代码中可以看出，当如下3个表达式的值为true时，accReq的值将为true，下面详细进行介绍。 

**1．refSuper&&\!needsPrivateAccess\(sym\)表达式的值为true**

当成员访问的限制符为“C.super”形式时，refSuper的值为true，其中C代表类型名称。当refSuper的值为true并且访问的不是私有成员时需要添加对应的获取方法，举个例子如下： 

【实例15\-17】

---

```java
package chapter15;
class Parent{
    int a = 1;
}
class Sub extends Parent {
    class Inner {
        public void md() {
            int b = Sub.super.a; 
        }
    }
}
```

---

其中Sub.super.a这样的引用形式需要添加获取方法，refSuper的值为true并且不是获取的私有变量，所以调用needsPrivateAccess\(\)方法返回false，表示式的值为true，需要添加获取方法。关于使用C.super形式访问父类成员的内容，将在第15.4.3节详细介绍。 

**2．调用needsProtectedAccess\(sym, tree\)方法返回true**

needsProtectedAccess\(\)方法的实现如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
boolean needsProtectedAccess(Symbol sym, JCTree tree) {
    if ((sym.flags() & PROTECTED) == 0 ||
        sym.owner.owner == currentClass.owner || 
        sym.packge() == currentClass.packge())
        return false;
    if (!currentClass.isSubClass(sym.owner, types))
        return true;
}
```

---

其中sym就是被引用的符号，currentClass就是引用sym的那个类。当前方法判断的是，由protected修饰的sym是否需要添加获取方法，当sym没有protected修饰时直接返回false，表示不需要添加获取方法。被引用的符号所定义的类与引用符号的类处在同一个包下，那么protected成员在相同包中仍然能够正常访问，不需要添加获取方法。由于大部分情况是当前定义一个protected修饰的成员，然后在当前类内使用，所以可通过sym.owner.owner是否等于currentClass.owner进行快速判断，当然也可以通过调用sym与currentClass.packge\(\)方法进行判断，但是效率差一些。 

如果当前类currentClass不为sym.owner的子类则返回true，表示需要添加获取方法，因为如果为非子类，则没有权限获取父类的由protected修饰的成员。举个例子如下： 

【实例15\-18】

---

```java
package compile;
public class Parent{
    protected int a = 1;
}
```

---

然后在另外一个包中访问成员变量a，举例如下： 

【实例15\-18】（续）

---

```java
package chapter15;
import compile.Parent;
class Sub extends Parent {
    class Inner {
        int x = a;
    }
}
```

---

由于当前currentClass为Inner类，所以这个类与定义变量a的类Parent没有父子关系，所以需要添加获取方法。 

**3．调用needsPrivateAccess\(sym\)方法返回true**

needsPrivateAccess\(\)方法在前一节详细介绍过，这里不再介绍。 

如果以上3个表达式的值为true，那么相关成员的访问就需要通过获取方法来访问了。下面继续介绍access\(\)方法的实现。当accReq变量的值为true时需要添加获取方法，同时也需要更新成员变量的访问方式。access\(\)方法中的相关实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
JCExpression base = (tree.getTag() == JCTree.SELECT) ? ((JCFieldAccess)
tree).selected : null;
if (accReq) {
     List<JCExpression> args = List.nil();
     if ((sym.flags() & STATIC) == 0) {
           if (base == null)
              base = makeOwnerThis(_, sym, _);
           args = args.prepend(base);
           base = null;  
    }
    Symbol access = accessSymbol(sym, tree,enclOp, protAccess,refSuper);
    JCExpression receiver = make.Select(
           base != null ? base : make.QualIdent(access.owner), access);
    return make.App(receiver, args);
} 
```

---

参数sym就是被引用的符号，tree就是引用的树节点。当accReq变量值为true时，需要调用accessSymbol\(\)方法添加获取方法，同时也要更新访问方式。在更新访问方式时，首先需要计算base变量的值，举个例子如下： 

【实例15\-19】

---

```java
class Outer {
    private int a = 1;
    private int b = 2;
    private static int c = 3;
    class Inner {
        int x = a;
        int y = new Outer().b;
        int z = new Outer().c;
    }
}
```

---

实例15\-19解语法糖后变为如下形式： 

---

```java
class Outer {
    
    /*synthetic*/ static int access$200() {
        return c;
    }
    
    /*synthetic*/ static int access$100(Outer x0) {
        return x0.b;
    }
    
    /*synthetic*/ static int access$000(Outer x0) {
        return x0.a;
    }
    private int a = 1;
    private int b = 2;
    private static int c = 3;
}
class Outer$Inner {
    /*synthetic*/ final Outer this$0;    
    Outer$Inner(/*synthetic*/ final Outer this$0) {
        this.this$0 = this$0;
        super();
}
    int x = Outer.access$000(this$0);
    int y = Outer.access$100(new Outer());
    int z = new Outer().access$200();
}
```

---

如果sym没有static修饰，在调用获取方法时需要追加base参数到实际参数列表头部。如果base为空，还需要调用makeOwnerThis\(\)方法获取，例如实例15\-19中对变量a的引用，调用makeOwnerThis\(\)方法获取的base为JCIdent\(this\$0\)。有了调用获取方法的实际参数列表后，就会创建调用获取方法的表达式receiver了，对于a变量来说，计算的receiver为JCFieldAccess\(Outer.access\$000\)，最后access\(\)方法返回JCMethodInvocation对象。 

如果sym是实例成员，base就是具体的实例，要访问base实例中的sym成员变量，需要向获取方法传递参数。例如，对于new Outer\(\).b表达式来说，将new Outer\(\)作为参数传递给获取方法access\$100\(\)。由于new Outer\(\).b是JCFieldAccess类型的节点，所以直接取selected的值作为base即可。计算的receiver为JCFieldAccess\(Outer.access\$100\)，最后access\(\)方法返回JCMethodInvocation对象。 

如果sym是静态成员，base可以是类型名称或具体的实例。例如对于new Outer\(\).c表达式来说，base直接取JCFieldAccess节点的selected值即可，计算的receiver为JCFieldAccess\(new Outer\(\).access\$200\)，最后access\(\)方法返回JCMethodInvocation对象。 

下面介绍在access\(\)方法中调用的accessSymbol\(\)方法的实现，代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
ClassSymbol accOwner = refSuper && protAccess
        ? (ClassSymbol)((JCFieldAccess) tree).selected.type.tsym
        : accessClass(sym, protAccess, tree);
Symbol vsym = sym;
if (sym.owner != accOwner) {
    vsym = sym.clone(accOwner);
    actualSymbols.put(vsym, sym);
}
```

---

accessSymbol\(\)方法首先计算accOwner的值，获取方法会作为accOwner的一个成员存在，所以获取方法最终会填充到accOwner.members\_field中。当refSuper与protAccess的值同时为true时，accOwner的值从标注语法树中获取，举个例子如下： 

【实例15\-20】

---

```java
package chapter15;
import compile.Parent;
class Sub extends Parent{
    class Inner{
        int x = Sub.super.a;     
    }
}
```

---

Sub类的父类Parent使用实例15\-18中定义的Parent类。当处理变量x的初始化表达式Sub.super.a时，refSuper与protAccess的值为true，则accOwner为ClassSymbol\(name=Sub\)，最终合成的获取方法会添加到Sub类中。由于被引用的变量a定义在Parent类中，而accOwner对应的类为Sub，所以会克隆一个vsym并通过actualSymbols集合保存vsym到实际符号的映射。其中，vsym.owner的值变为了accOwner，这样后续在translateTopLevel Class\(\)方法中会遍历保存所有vsym、类型为ListBuffer\<Symbol\>的列表accessed，然后调用makeAccessible\(\)方法根据vsym.owner的值来确定JCClassDecl对象，合成的获取方法会添加到这个对象中。 

actualsSymbols变量的定义如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower 
Map<Symbol,Symbol> actualSymbols;  
```

---

actualsSymbols变量中保存的信息将为后面生成具体的获取方法提供必要的信息。 

如果refSuper或protAccess中至少有一个为false时，会调用accessClass\(\)方法计算accOwner，这个方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
ClassSymbol accessClass(Symbol sym, boolean protAccess, JCTree tree) {
    if (protAccess) {
        Symbol qualifier;
        ClassSymbol c = currentClass;
        if (tree.getTag() == JCTree.SELECT && (sym.flags() & STATIC) == 0) {
            qualifier = ((JCFieldAccess) tree).selected.type.tsym;
            while (!qualifier.isSubClass(c, types)) {
                c = c.owner.enclClass();
            }
            return c;
        } else {
            while (!c.isSubClass(sym.owner, types)) {
                c = c.owner.enclClass();
            }
        }
        return c;
    } else {
        return sym.owner.enclClass();  // the symbol is private
    }
}
```

---

当protAccess为false时，直接返回sym.owner.enclClass\(\)表达式的值，也就是sym肯定是私有成员，因为前面在介绍accReq时介绍过protAccess，当此值为false而accReq的值为true（在access\(\)方法中判断，只有accReq的值为true时才会调用accessClass\(\)方法）时，那么肯定是调用needsPrivateAccess\(\)方法返回了true，直接将获取方法添加到定义私有成员的类中。 

当protAccess为true时，说明refSuper为false，这样才会调用accessClass\(\)方法，这个方法主要是计算ClassSymbol对象c的值，也就是计算获取方法需要添加到哪个类中。举个例子如下： 

【实例15\-21】

---

```java
package chapter15;
import compile.Parent;
class Sub extends Parent{
    class Inner{
        int x = a;     
    }
}
```

---

Sub类的父类Parent使用实例15\-18中定义的Parent类。在调用accessClass\(\)方法时，sym的值为VarSymbol\(name=a\)，protAccess的值为true，tree的值为JCIdent\(name=a\)，currentClass的值为ClassSymbol\(name=Inner\)。accessClass\(\)方法首先判断Inner类是否为sym.owner的子类，由于sym.owner为Parent类，很明显不是，将c的值更新为ClassSymbol\(name=Sub\)，Sub类是Parent的子类，所以c的值最终为ClassSymbol\(name=Sub\)，获取方法会添加到Sub类中。 

继续看accessSymbol\(\)方法的实现，代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
Integer anum = accessNums.get(vsym);
if (anum == null) {
    anum = accessed.length();
    accessNums.put(vsym, anum);
    accessSyms.put(vsym, new MethodSymbol[NCODES]);
    accessed.append(vsym);
}
```

---

其中涉及accessed、accessNums与accessSyms，这几个变量的定义如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
private Map<Symbol,Integer> accessNums;
private Map<Symbol,MethodSymbol[]> accessSyms;
private ListBuffer<Symbol> accessed;
```

---

accessNums在生成获取方法的名称时提供编号，如实例15\-19，为同一个类中的3个私有变量生成获取方法，名称依次为access$000、access$100和access$200，“$”字符后的数字0、1与2就是accessNums提供的。accessSyms存储了成员到获取方法的映射关系，同一个成员的使用方式不同，就会生成不同的获取方法，所以一个具体的vsym对应一个MethodSymbol类型的数组，初始化时指定大小为98。后面将会详细介绍为什么需要一个初始容量为98大小的数组。accessed存储所有的vsym对象。通过如上的3个属性及之前的actualSymbols属性，在合成方法时可以获取任何想要的信息。 

下面就是要生成具体的获取方法了，在生成获取方法时首先要得到方法的相关信息，如名称及形式参数等，实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
int acode;               // 在合成获取方法的名称时使用
List<Type> argtypes;      // 保存获取方法的形式参数
Type restype;             // 保存获取方法的返回类型
List<Type> thrown;        // 保存获取方法的异常抛出类型
switch (vsym.kind) {
case VAR:
    acode = accessCode(tree, enclOp);
    if (acode >= FIRSTASGOPcode) {
        OperatorSymbol operator = binaryAccessOperator(acode);
        if (operator.opcode == string_add)
            argtypes = List.of(syms.objectType);
        else
            argtypes = operator.type.getParameterTypes().tail;
    } else if (acode == ASSIGNcode)
        argtypes = List.of(vsym.erasure(types));
    else
        argtypes = List.nil();
    restype = vsym.erasure(types);
    thrown = List.nil();
    break;
case MTH:
    acode = DEREFcode;
    argtypes = vsym.erasure(types).getParameterTypes();
    restype = vsym.erasure(types).getReturnType();
    thrown = vsym.type.getThrownTypes();
    break;
}
```

---

以上代码中为即将生成的获取方法收集必要的信息，当vsym为变量或方法时，需要为获取方法计算acode、argtypes、restype与thrown，不过当vsym为方法时计算相对比较简单。acode为获取方法名称的一部分，当vsym为变量时，调用accessCode\(\)方法计算acode值。 

通常，acode算出来的是0～96的所有偶数。首先来认识0～12之间的偶数定义，代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
private static final int
    DEREFcode = 0,
    ASSIGNcode = 2,
    PREINCcode = 4,
    PREDECcode = 6,
    POSTINCcode = 8,
    POSTDECcode = 10,
    FIRSTASGOPcode = 12;
```

---

所以当访问的成员是方法时，获取方法的名称中acode的值永远为DEREFcode，也就是0。 

accessCode\(\)方法的实现代码如下： 

---

```java

来源：com.sun.tools.javac.comp.Lower
private static int accessCode(JCTree tree, JCTree enclOp) {
    if (enclOp == null)
        return DEREFcode;
    else if (enclOp.getTag() == JCTree.ASSIGN && tree == TreeInfo.skipParens
(((JCAssign) enclOp).lhs))
        return ASSIGNcode;
    else if (JCTree.PREINC <= enclOp.getTag() && enclOp.getTag() <= JCTree.
POSTDEC &&
             tree == TreeInfo.skipParens(((JCUnary) enclOp).arg))
        return (enclOp.getTag() - JCTree.PREINC) * 2 + PREINCcode;
    else if (JCTree.BITOR_ASG <= enclOp.getTag() && enclOp.getTag() <= 
JCTree.MOD_ASG &&
             tree == TreeInfo.skipParens(((JCAssignOp) enclOp).lhs)) // todo
        return accessCode(((OperatorSymbol) ((JCAssignOp) enclOp).operator).
opcode);
    else
        return DEREFcode;
}
```

---

当enclOp为null时返回DEREFcode；当enclOp等于JCTree.ASSIGN时返回ASSIGNcode；当enclOp大于等于JCTree.PREINC而小于等于JCTree.POSTDEC时，返回对应的PREINCcode、PREDECcode、POSTINCcode或POSTDECcode；当enclOp大于等于JCTree.BITOR\_ASG而小于等于JCTree.MOD\_ASG时，其实就是判断当前的二元表达式对应的树节点中运算符是否为复合运算符，JCTree.BITOR\_ASG就是|=，对应值为76，而JCTree.MOD\_ASG就是%=，对应值为92，在数值76~92之间都是复合操作符。对于JCAssignOp树节点来说，其operator属性的类型为OperatorSymbol，在符号引用消解时会找到对应的预先建立的OperatorSymbol对象，获取opcode就是ByteCodes中的编码，然后调用accessCode\(\)方法。accessCode\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
private static int accessCode(int bytecode) {
    if (ByteCodes.iadd <= bytecode && bytecode <= ByteCodes.lxor)
        return (bytecode - iadd) * 2 + FIRSTASGOPcode;
    else if (bytecode == ByteCodes.string_add)
        return (ByteCodes.lxor + 1 - iadd) * 2 + FIRSTASGOPcode;
    else if (ByteCodes.ishll <= bytecode && bytecode <= ByteCodes.lushrl)
        return (bytecode - ishll + ByteCodes.lxor + 2 - iadd) * 2 + FIRSTASGOP code;
    else
        return -1;
}
```

---

通过判断，计算最终的数值，如表15\-1所示。 

表15\-1　编码到编号的映射 

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230418/image.44of639vzhq0.webp)

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230418/image.1uzeefkf9bls.webp)

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230418/image.6v7ai2rb7to0.webp)

表15\-1中的助词符是ByteCodes类中定义的，编号从96~131与实际的虚拟机指令编码对应，而256及270~275都是Javac虚拟出来的指令，并没有Java虚拟机对应的指令存在。在代码生成的过程中会将270~275的虚拟指令对应映射到120~125上，这样Java语言就支持了移位时右侧操作数可以为long类型的语法。 

调用accessCode\(int bytecode\)方法可能返回12~96之间的任何偶数，所以与前面从0~12之间定义的常量合并后，方法accessCode\(JCTree tree,JCTree enclOp\)可能返回0~96之间的任何偶数。其实在accessSymbol\(\)方法中计算出acode后，在生成获取方法之前还会执行如下的计算逻辑： 

---

```java
来源：com.sun.tools.javac.comp.Lower 
if (protAccess && refSuper)      
  acode++;  
```

---

当protAccess与refSuper的属性值同时为true时，acode加1，这样就相当于可能取0~97之间的任何数据。一个成员对应生成的获取方法，可根据使用方式的不同生成最多98个获取方法，这就是将accessSyms集合中MethodSymbol数组的大小初始化为98的原因。至于protAccess与refSuper的值同时为true时，为什么要将acode的值加1，将在一下节介绍。 

下面简单举一个根据成员使用方式的不同生成不同的获取方法的例子。 

【实例15\-22】

---

```java
class Outer {
    private int a = 1;
    class Inner {
        public void md() {
            int b = a; // deref
            a = 2; // assign
            int c;
            c = ++a; // preinc
            c = --a; // predec
            c = a++; // postinc
            c = a--; // postdec
            a += 1; // first assignment op
        }
    }
}
```

---

实例解语法糖后变为如下等价的形式： 

---

```java
class Outer {
    
    /*synthetic*/ static int access$012(Outer x0, int x1) {
        return x0.a += x1;
    }
    
    /*synthetic*/ static int access$010(Outer x0) {
        return x0.a--;
    }
    
    /*synthetic*/ static int access$008(Outer x0) {
        return x0.a++;
    }
    
    /*synthetic*/ static int access$006(Outer x0) {
        return --x0.a;
    }
    
    /*synthetic*/ static int access$004(Outer x0) {
        return ++x0.a;
    }
    
    /*synthetic*/ static int access$002(Outer x0, int x1) {
        return x0.a = x1;
    }
    
    /*synthetic*/ static int access$000(Outer x0) {
        return x0.a;
    }
    
    private int a = 1;
}
class Outer$Inner {
    /*synthetic*/ final Outer this$0;
    
    Outer$Inner(/*synthetic*/ final Outer this$0) {
        this.this$0 = this$0;
        super();
    }
    
    public void md() {
        int b = Outer.access$000(this$0);
        Outer.access$002(this$0, 2);
        b = Outer.access$004(this$0);
        b = Outer.access$006(this$0);
        b = Outer.access$008(this$0);
        b = Outer.access$010(this$0);
        Outer.access$012(this$0, 1);
    }
}
```

---

可以看到，对私有变量a来说，使用的方式不同会生成不同的获取方法。对于获取方法名称的后两个字符来说，就是在accessSymbol\(\)方法中调用accessCode\(\)方法获取到的acode，然后通过acode / 10 \+ acode % 10来得到获取方法名称的后两位字符。 

接着看accessSymbol\(\)方法的实现。当vsym为变量并且调用accessCode\(\)方法获取acode后，当acode大于等于FIRSTASGOPcode时，也就是enclOp为复合赋值表达式时，调用binarAccessOperator\(\)方法获取OperatorSymbol对象，通过这个对象可以获取在调用获取方法时使用的实际参数的类型。binaryAccessOperator\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
private OperatorSymbol binaryAccessOperator(int acode) {
    for (Scope.Entry e = syms.predefClass.members().elems;e != null;e =
e.sibling) {
        if (e.sym instanceof OperatorSymbol) {
            OperatorSymbol op = (OperatorSymbol)e.sym;
            if (accessCode(op.opcode) == acode) 
                return op;
        }
    }
    return null;
}
```

---

实现逻辑很简单，就是通过acode取出对应的OperatorSymbol对象并返回。在得到operator后判断：如果operator的opcode为string\_add，向获取方法的形式参数列表的类型中追加Object类型，否则追加operator的形式参数中除第一个类型外的所有类型。举个例子如下： 

【实例15\-23】

---

```java

class Outer{
    private String a = "helloworld";
    private long b = 1;
    class Inner {
        public void md() {
            a += 1;
            b += 1;
        }
    }
}
```

---

实例解语法糖后变为如下形式： 

---

```java
class Outer$Inner {
    /*synthetic*/ final Test this$0;    
    Outer$Inner(/*synthetic*/ final Outer this$0) {
        this.this$0 = this$0;
        super();
    }    
    public void md() {
        Outer.access$084(this$0, String.valueOf(1));
        Outer.access$114(this$0, 1);
    }
}
class Outer{    
    /*synthetic*/ static long access$114(Outer x0, long x1) {
        return x0.b += x1;
    }    
    /*synthetic*/ static String access$084(Outer x0, Object x1) {
        return x0.a += x1;
    }    
    private String a = "helloworld";
    private long b = 1;
}
```

---

可以看到，获取方法access\$114\(\)最后一个形式参数的类型为long，而access\$084\(\)方法的最后一个形式参数的类型为Object。 

在accessSymbol\(\)方法中计算好获取方法的相关信息后就可以生成具体的获取方法了，代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
if ((vsym.flags() & STATIC) == 0) {
    argtypes = argtypes.prepend(vsym.owner.erasure(types));
}
MethodSymbol[] accessors = accessSyms.get(vsym);
MethodSymbol accessor = accessors[acode];
if (accessor == null) {
    accessor = new MethodSymbol( STATIC | SYNTHETIC, accessName(anum.
intValue(), acode),
        new MethodType(argtypes, restype, thrown, syms.methodClass),accOwner);
    enterSynthetic(_, accessor, accOwner.members());
    accessors[acode] = accessor;
}
return accessor;
```

---

当vsym代表的是实例成员时还需要为生成方法的形式参数追加类型，通过vsym.owner.erauser\(types\)获取，然后获取accessors数组中指定的MethodSymbol对象accessor。如果对象不存在，则需要合成，如果存在，说明之前已经合成了相关的获取方法，直接返回即可。 

### 15.4.3　super关键字引用父类成员 

举个例子如下： 

【实例15\-24】

---

```java
package chapter15;
class Parent{
    int a = 1;
}
class Sub extends Parent {
    private int a = 2;
    class Inner {
        public void md() {
            int b = Sub.super.a; // deref
            Sub.super.a = 2; // assign
        }
    }
}
```

---

实例解语法糖后变为如下形式： 

---

```java
class Sub extends Parent {
    
    /*synthetic*/ static int access$103(Sub x0, int x1) {
        return x0.a = x1;
    }
    
    /*synthetic*/ static int access$001(Sub x0) {
        return x0.a;
    }
    private int a = 2;
}
class Sub$Inner {
    /*synthetic*/ final Sub this$0;
    
    Sub$Inner(/*synthetic*/ final Sub this$0) {
        this.this$0 = this$0;
        super();
    }
    
    public void md() {
        int b = Sub.access$001(this$0);
        Sub.access$103(this$0, 2);
    }
}
```

---

通过super关键字访问父类成员变量a时，最终会调用获取方法access\$103\(\)与access \$001\(\)来访问。获取方法名称的后两位变为了奇数，这就是之前提到的在accessSymbol\(\)方法中调用accessCode\(\)方法获取完acode时，如果protAccess与refSuper变量的值为true，还会将acode的值加1。代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
if (protAccess && refSuper) 
    acode++;
```

---

实例15\-24中解语法糖后的形式与之前的程序并不等价，因为对于Sub类中生成的获取方法来说，调用x0.a获取到的是Sub类内定义的私有变量，不过从标注语法树来看，FieldAccess\(x0.a\)树节点的sym指向的是Parent类中定义的变量a，所以引用完全正确，不需要进行任何特殊处理。但是在引用方法时情况就不一样了，举个例子如下： 

【实例15\-25】

---

```java
package chapter15;
class Parent {
    public void md(){ }
}
class Sub extends Parent {
    public void md(){ }
    class Inner {
        public void test() {
            Sub.super.md();
        }
    }
}
```

---

实例在解语法糖后变为如下形式： 

---

```java
package chapter15;
class Sub extends Parent {    
    /*synthetic*/ static void access$001(Sub x0) {
        x0.md();
    }   
    public void md() { }
}
class Sub$Inner {
    /*synthetic*/ final Sub this$0;
    
    Sub$Inner(/*synthetic*/ final Sub this$0) {
        this.this$0 = this$0;
        super();
    }    
    public void test() {
        Sub.access$001(this$0);
    }
}
```

---

在access\$001\(\)方法中调用x0.md\(\)方法会调用到Sub类中定义的md\(\)方法，显然这种调用方式与之前的程序不符，不过在生成字节码的过程中会判断，如果当前方法是以access\$开头并且最后的两位数为奇数时，在调用md\(\)方法时会使用invokespecial指令，否则使用invokevirtual指令。 

方法access$001\(\)最终生成的字节码如下： 

---

```java
0: aload_0
1: invokespecial #1   // Method chapter15/Parent.md:()V
4: return
```

---

在调用md\(\)方法时选择的指令为invokespecial，所以还是正常调用到了Parent类中的md\(\)方法。 

### 15.4.4　访问自由变量 

本地类在一些情况下会通过合成获取方法的方式来访问成员，包括成员类、成员变量和成员方法，但是本地类中还会访问另外一些变量，比如方法上传递的形式参数，方法内定义的非编译时常量，这些变量统称为自由变量。举个例如下： 

【实例15\-26】

---

```java
class Outer {
    public void md(final int a) {
        final Integer b = new Integer(1);
        final int c = 1;
        class Local {
            int x1 = a;
            Integer x2 = b;
            int x3 = c;
        }
        Local l = new Local();
    }
}
```

---

实例在解语法糖后变为如下形式： 

---

```java
class Outer {
    public void md(final int a) {
        final Integer b = new Integer(1);
        final int c = 1;
        Outer$1Local l = new Outer$1Local(this, a, b);
    }
}
class Outer$1Local {
    /*synthetic*/ final Outer this$0;
    /*synthetic*/ final Integer val$b;
    /*synthetic*/ final int val;    
    Outer$1Local(/*synthetic*/ final Outer this$0, /*synthetic*/ final int val, /*synthetic*/ final Integer val$b) {
        this.this$0 = this$0;
        this.val = val;
        this.val$b = val$b;
        super();
    }
    int x1 = val;
    Integer x2 = val$b;
    int x3 = 1;
}
```

---

本地类Local解语法糖后变为Outer\$1Local，由于Local类引用了自由变量a与b，所以会在Outer\$1Local类中合成对应的成员变量val与val\$b，然后通过构造方法初始化，初始化后的val\$b与val就可以替换本地类中对自由变量a与b的引用了。上面已经对变量x1与x2的初始化表达式进行了替换，而对于x3，由于引用的是编译时常量，所以直接替换为c的常量值1即可。 

在调用的构造方法中，第一个参数必须为Outer对象this\$0，这是因为Outer\$1Local实例的存在依赖于Outer实例，通过这样的方式可以保证在创建本地类实例时外部类实例已经存在。 

在Outer类内创建Local类的实例时，需要为新的构造方法传递实际参数，这样通过解语法糖后本地类就可以完成对外部类自由变量的访问了。 

在类Outer\$1Local的构造方法中，将合成变量的初始化放在调用父类super\(\)方法之前，代码编写者只能将方法调用语句super\(\)放在子类构造方法的第一行，只是为了一定程度上保证在子类可以访问父类对象之前要完成对父类对象的初始化，但这样并不能完全避免父类初始化时不会访问父类对象，这里不访问父类对象，所以可以放在调用语句super\(\)之前。 

Javac对自由变量解语法糖的实现比较复杂，考虑的情况也比较多，这里只介绍一些常用的实现，读者可以自行阅读源代码了解更多关于解语法糖的具体实现。 

从实例15\-26可以看出，要想对本地变量解语法糖，至少需要经过如下几个步骤： 

1. 收集被本地类引用的自由变量。 
2. 在本地类中合成相关的成员变量并更新原有构造方法，在构造方法中初始化这些成员变量。 
3. 更新本地类中引用自由变量的方式，替换为引用合成的成员变量。 
4. 更新对本地类中构造方法的调用，主要是在创建本地类的对象时，为构造方法传递实际参数。

下面介绍以上4个步骤的具体实现。 

**1．收集被本地类引用的自由变量**

对本地类解语法糖时，首先会访问Lower类的visitClassDef\(\)方法，这个方法中有如下实现： 

---

```java
来源：com.sun.tools.javac.comp.Lower 
freevars(currentClass)  
```

---

其中，currentClass就是当前类对应的ClassSymbol对象，调用freevars\(\)方法收集所有currentClass中使用到的自由变量，该方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
List<VarSymbol> freevars(ClassSymbol c)  {
    if ((c.owner.kind & (VAR | MTH)) != 0) {
        List<VarSymbol> fvs = freevarCache.get(c);
        if (fvs == null) {
            FreeVarCollector collector = new FreeVarCollector(c);
            collector.scan(classDef(c));
            fvs = collector.fvs;
            freevarCache.put(c, fvs);
        }
        return fvs;
    } else {
        return List.nil();
    }
}
```

---

当c为本地类或匿名类并且之前没有针对此类进行自由变量收集时，需要获取自由变量列表fvs。其中，freevarCache是Map\<ClassSymbol,List\<VarSymbol\>\>对象，用于缓存查找过的自由变量列表，达到重用的目的。调用classDef\(\)方法查找c所对应的JCClassDecl语法树，创建FreeVarCollector对象并调用scan\(\)方法扫描JCClassDecl语法树，最后返回查找到的自由变量列表fvs。 

需要注意的是，当前类所属的符号是变量或方法时才会进行自由变量收集，举个例子如下： 

【实例15\-27】

---

```java
class Outer {
    public void md(final int a) {
        class Local {
            class MyClass{
                int x1 = a;
            }
        }
    }
}
```

---

不针对Outer与MyClass类收集自由变量，只对Local类收集自由变量。在对Local类进行自由变量收集时，会扫描Local类对应的语法树节点下的所有子节点，如MyClass类中对自由变量a进行了引用，在收集Local类的自由变量时，会收集到变量a。FreeVarCollector类可以扫描Local类对应的语法树节点下的所有子节点，这个类继承了TreeScanner类并选择性覆写了visitXxx\(\)方法。通过visitXxx\(\)方法找到某些表达式对变量的引用时就会调用visitSymbol\(\)方法，这个方法的主要实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower.FreeVarCollector
private void visitSymbol(Symbol _sym) {
    Symbol sym = _sym;
    if (sym.kind == VAR ) {
        if (sym != null && sym.owner == owner) {
            VarSymbol v = (VarSymbol)sym;
            if (v.getConstValue() == null) {
                addFreeVar(v);
            }
        } 
    }
}
```

---

当参数\_sym是定义在方法中的变量并且不是编译时常量时，调用addFreeVar\(\)方法向fvs列表中追加自由变量，fvs是FreeVarCollector类中声明的一个类型为List\<VarSymbol\>的成员变量，在freevars\(\)方法中通过collector.fvs语句获取的正是这个变量的值。owner是FreeVarCollector类中声明的一个类型为MethodSymbol的成员变量，在创建FreeVarCollector对象时初始化。 

对于实例15\-26中的变量c来说，调用v.getConstValue\(\)方法的返回值不为空，所以不是自由变量。 

addFreeVar\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower.FreeVarCollector
private void addFreeVar(VarSymbol v) {
    for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail)
        if (l.head == v) 
            return;
    fvs = fvs.prepend(v);
}
```

---

当fvs列表中不含v时，将v添加到列表头部。 

下面介绍FreeVarCollector类中对visitIdent\(\)、visitNewClass\(\)与visitApply\(\)方法的实现，因为这些方法处理的表达式通常会对自由变量进行引用。 

**（1）visitIdent\(\)方法** 

visitIdent\(\)方法的主要实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower.FreeVarCollector 
visitSymbol(tree.sym);  
```

---

对于实例15\-26来说，Local类中对变量a、b与c的引用会调用visitIdent\(\)方法进行处理，这个方法调用visitSymbol\(\)方法将a与b添加到fvs列表中。 

**（2）visitNewClass\(\)方法** 

visitNewClass\(\)方法的主要实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower.FreeVarCollector 
ClassSymbol c = (ClassSymbol)tree.constructor.owner; 
addFreeVars(c);  
```

---

调用addFreeVars\(\)方法，实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower.FreeVarCollector
private void addFreeVars(ClassSymbol c) {
    List<VarSymbol> fvs = freevarCache.get(c);
    if (fvs != null) {
        for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {
            addFreeVar(l.head);
        }
    }
}
```

---

首先查找被引用的类c是否有对应的自由变量列表，如果没有，说明c不是本地类或者c没有访问任何自由变量；如果fvs列表不为空，将c中访问的自由变量也添加到当前类的自由变量列表中。举个例子如下： 

【实例15\-28】

---

```java
class Test {
    public void md(final int a) {
        class LocalA{
            public int x1 = a;
        }
        class LocalB{
            LocalA x2 = new LocalA();
        }
    }
}
```

---

调用visitNewClass\(\)方法处理LocalB类中x2变量的初始化表达式，这个方法会将LocalA类中访问的自由变量a也加入到LocalB的自由变量列表中，两个本地类LocalA和LocalB在解语法糖后变为如下形式： 

---

```java
class Test$1LocalA {
    /*synthetic*/ final Test this$0;
    /*synthetic*/ final int val;
    
    Test$1LocalA(/*synthetic*/ final Test this$0, /*synthetic*/ final int val) {
        this.this$0 = this$0;
        this.val = val;
        super();
    }
    public int x1 = val;
}
class Test$1LocalB {
    /*synthetic*/ final Test this$0;
    /*synthetic*/ final int val;
    
    Test$1LocalB(/*synthetic*/ final Test this$0, /*synthetic*/ final int val) {
        this.this$0 = this$0;
        this.val = val;
        super();
    }
    Test$1LocalA x2 = new Test$1LocalA(this$0, val);
}
```

---

可以看到，Test\$1LocalB类中也合成了变量a对应的成员变量，对于x2变量的初始化表达式来说，只有有了val才能创建Test\$1LocalA对象。 

**（3）visitApply\(\)方法** 

visitApply\(\)方法的主要实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower.FreeVarCollector
if (TreeInfo.name(tree.meth) == names._super) {
    addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);
}
```

---

当处理形如super\(...\)这样的调用父类构造方法的语句时，需要调用addFreeVars\(\)方法处理父类，如果父类有对自由变量的引用也会添加到当前类的自由变量中，举个例子如下： 

【实例15\-29】

---

```java
class Test {
    public void md(final int a) {
        class LocalA {
            int x1 = a;
        }
        class LocalB extends LocalA {
            LocalB() {
                super();
            }
        }
    }
}
```

---

两个本地类LocalA和LocalB在解语法糖后变为如下形式： 

---

```java
class Test$1LocalA {
    /*synthetic*/ final Test this$0;
    /*synthetic*/ final int val;
    
    Test$1LocalA(/*synthetic*/ final Test this$0, /*synthetic*/ final int
val) {
        this.this$0 = this$0;
        this.val = val;
        super();
    }
    int x1 = val;
}
class Test$1LocalB extends Test$1LocalA {
    /*synthetic*/ final Test this$0;
    /*synthetic*/ final int val;
    
    Test$1LocalB(/*synthetic*/ final Test this$0, /*synthetic*/ final int
val) {
        this.this$0 = this$0;
        this.val = val;
        super(this$0, val);
    }
}
```

---

可以看到，虽然Test$1LocalB类中没有访问自由变量a，但还是合成了对应的val成员变量，因为父类访问了自由变量a并且需要在子类调用父类的构造方法时传递实际的参数进行初始化。 

**2．在本地类中合成相关的成员变量并更新原有构造方法，在构造方法中初始化这些成员变量**

对于内部类来说，需要保持一个对外部类实例的引用，所以在处理本地类时，会在Lower类的visitClassDef\(\)方法中合成一个名称以“this$”字符串开头的成员变量，相关的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
proxies = proxies.dup(currentClass);
List<VarSymbol> prevOuterThisStack = outerThisStack;
JCVariableDecl otdef = null;
if (currentClass.hasOuterInstance())
    otdef = outerThisDef(_, currentClass);
if (currentClass.hasOuterInstance()) {
    tree.defs = tree.defs.prepend(otdef);
    enterSynthetic(_, otdef.sym, currentClass.members());
}
...
proxies = proxies.leave();
outerThisStack = prevOuterThisStack;
```

---

内部类都会调用outerThisDef\(\)方法合成一个名称以“this$”开头的变量，将这个变量对应的语法树追加到tree.defs中，同时将这个变量对应的符号otdef.sym填充到currentClass.members\_field中，这样这个变量就是当前类的一个成员变量了。 

proxies用来保存自由变量对应的成员变量的符号，outerThisStack用来保存封装类的实例变量，也就是调用outerThisDef\(\)方法合成的名称以“this$”开头的变量。outerThisDef\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
JCVariableDecl outerThisDef(_, Symbol owner) {
    long flags = FINAL | SYNTHETIC;
    Type target = types.erasure(owner.enclClass().type.getEnclosingType());
    VarSymbol outerThis = new VarSymbol(flags, outerThisName(target, owner),
target, owner);
    outerThisStack = outerThisStack.prepend(outerThis);
    JCVariableDecl vd = make.VarDef(outerThis, null);
    return vd;
}
```

---

outerThisDef\(\)方法在创建VarSymbol对象outerThis之前，会调用outerThisName\(\)方法合成一个名称以“this$”字符串开头的变量，同时将outerThis追加到outerThisStack列表的头部。 

outerThisName\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
Name outerThisName(Type type, Symbol owner) {
    Type t = type.getEnclosingType();
    int nestingLevel = 0;
    while (t.tag == CLASS) {
        t = t.getEnclosingType();
        nestingLevel++;
    }
    Name result = names.fromString("this" + target.syntheticNameChar() +
nestingLevel);
    // 向新合成的字符串名称末尾追加一个或多个'$'字符来避免冲突
    while (owner.kind == TYP && ((ClassSymbol)owner).members().lookup
(result).scope != null)
        result = names.fromString(result.toString() + target.synthetic
NameChar());
    return result;
}
```

---

通过循环得到当前类型type嵌套的层次nestingLevel，然后创建一个result对象，其中调用target.syntheticNameChar\(\)方法返回字符'\$'。outerThisName\(\)方法最后还会检测冲突，因为新合成的名称有可能已经被使用，这时候可以通过向新合成的字符串名称末尾追加一个或多个'\$'字符来避免冲突。举个例子如下： 

【实例15\-30】

---

```java

package chapter15;
class OuterA {
    class OuterB {
        // final OuterA this$0合成的变量
        class OuterC {
            // final OuterA$OuterB this$1合成的变量
        }
    }
}
```

---

在OuterB中合成的成员变量的名称一般为this\$0，而在OuterC中合成的成员变量的名称一般为this\$1。在调用outerThisDef\(\)方法时，如果参数owner表示OuterB类，向outerThisStack列表中追加VarSymbol\(name=this\$0\)，如果参数owner表示OuterC类，向已经有VarSymbol\(name=this\$0\)的outerThisStack列表的头部追加VarSymbol\(name=this\$1\)。 

接着介绍Lower类中的visitClassDef\(\)方法的实现，当合成了外部类实例的成员后就需要合成引用的自由变量所对应的成员变量了，相关的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
List<JCVariableDecl> fvdefs = freevarDefs(_, freevars(currentClass),
 currentClass);
for (List<JCVariableDecl> l = fvdefs; l.nonEmpty(); l = l.tail) {
    tree.defs = tree.defs.prepend(l.head);
    enterSynthetic(_, l.head.sym, currentClass.members());
}
```

---

当currentClass为本地类时，调用freevars\(\)方法获取本地类中引用的自由变量，然后调用freevarDefs\(\)方法在本地类中合成对应的成员变量，将成员变量对应的语法树追加到tree.defs中并将相关符号填充到currentClass.members\_field中。 

freevarDefs\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol
owner) {
    long flags = FINAL | SYNTHETIC;
    List<JCVariableDecl> defs = List.nil();
    for (List<VarSymbol> l = freevars; l.nonEmpty(); l = l.tail) {
        VarSymbol v = l.head;
        VarSymbol proxy = new VarSymbol(flags, proxyName(v.name), v.erasure
(types), owner);
        proxies.enter(proxy);
        JCVariableDecl vd = make.VarDef(proxy, null);
        defs = defs.prepend(vd);
    }
    return defs;
}
```

---

循环为每个被引用的自由变量创建对应的VarSymbol对象和JCVariableDecl对象，然后将创建好的VarSymbol对象填充到proxies作用域中。 

在创建VarSymbol对象之前，需要调用proxyName\(\)方法创建变量名称，这个方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
Name proxyName(Name name) {
    return names.fromString("val" + target.syntheticNameChar() + name);
}
```

---

新合成的成员变量的名称只需要在自由变量的名称之前追加“val$”字符串即可。 

在Lower类的visitClassDef\(\)方法中为本地类合成了封闭类实例对应的成员变量和自由变量对应的成员变量，接下来需要更新原有构造方法，在更新后的构造方法中初始化这些成员变量。调用Lower类的visitMethodDef\(\)方法更新构造方法，这个方法会调用visitMethodDefInternal\(\)方法，这个方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
private void visitMethodDefInternal(JCMethodDecl tree) {
    if (tree.name == names.init &&
        (currentClass.isInner() || (currentClass.owner.kind & (VAR | MTH))
 != 0)) {
        // 内部类的构造方法
        MethodSymbol m = tree.sym;
        // 从proxies中查找及保存成员变量和构造方法的形式参数
        proxies = proxies.dup(m);
        // 从outerThisStack中查找及保存封闭类的实例变量和构造方法的形式参数
        List<VarSymbol> prevOuterThisStack = outerThisStack;
        
        JCVariableDecl otdef = null;
        if (currentClass.hasOuterInstance())
            otdef = outerThisDef(_, m);
        List<VarSymbol> fvs = freevars(currentClass);
        List<JCVariableDecl> fvdefs = freevarDefs(_, fvs, m);
        // 向构造方法的形式参数的末尾追加能初始化自由变量对应的成员变量的参数
        tree.params = tree.params.appendList(fvdefs);
        // 向构造方法的形式参数的头部追加能初始化封闭类的实例变量的参数
        if (currentClass.hasOuterInstance())
            tree.params = tree.params.prepend(otdef);
        JCStatement selfCall = translate(tree.body.stats.head);
        List<JCStatement> added = List.nil();
        if (fvs.nonEmpty()) {
            for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {
                if (TreeInfo.isInitialConstructor(tree))
                    added = added.prepend(initField(_, proxyName(l.head.name)));
            }
        }
        if (currentClass.hasOuterInstance() && TreeInfo.isInitial
Constructor(tree)) {
            added = added.prepend(initOuterThis(_));
        }
        // 离开方法时，保存的构造方法的形式参数失效
        proxies = proxies.leave();
        List<JCStatement> stats = translate(tree.body.stats.tail);
        tree.body.stats = stats.prepend(selfCall).prependList(added);
        // 离开方法时，保存的构造方法的形式参数失效
        outerThisStack = prevOuterThisStack;
    } 
}
```

---

如果tree为内部类或本地类的构造方法时，需要对构造方法进行更新。首先调用outerThisDef\(\)方法和freevarDefs\(\)方法获取otdef与fvdefs，然后将otdef追加到构造方法形式参数列表的头部，而将fvdefs列表中的值追加到构造方法形式参数列表的末尾。 

为构造方法添加完形式参数后，就需要在构造方法中初始化合成的成员变量了。在初始化成员变量之前需要调用TreeInfo.isInitialConstructor\(\)方法判断当前构造方法的第一个语句不为this\(...\)形式，如果为this\(...\)形式，不会添加变量初始化语句。原因也很好理解，这个构造方法调用了另外的构造方法，如果在每个构造方法中进行初始化，那么变量就会被初始化多次，所以如果构造方法中的第一个语句是this\(...\)形式或super\(...\)形式时，还需要更新第一个语句，因为this\(...\)与super\(...\)调用的可能是更新过的构造方法，所以需要追加实际参数，实现步骤与即将介绍的第4步骤的实现类似，为了节省篇幅，这里暂不介绍。 

对于自由变量对应的成员变量的初始化，调用proxyName\(\)方法得到变量名称后调用initField\(\)方法，这个方法会返回初始化语句对应的语法树，将这些语法树追加到added列表中。initField\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
JCStatement initField(_, Name name) {
    Scope.Entry e = proxies.lookup(name);
    Symbol rhs = e.sym;
    Assert.check(rhs.owner.kind == MTH);
    Symbol lhs = e.next().sym;
    Assert.check(rhs.owner.owner == lhs.owner);
    return
        make.Exec(
            make.Assign(
                make.Select(make.This(lhs.owner.erasure(types)), lhs),
                make.Ident(rhs)).setType(lhs.erasure(types)));
}
```

---

对于合成的名称name，从proxies中查找对应的Scope.Entry对象。需要注意的是，在获取lhs的值时，需要调用e.next\(\)方法获取Scope.Entry对象的shadowed变量的值，因为两个符号的名称相同，并且合成的成员变量一定会先填充到proxies中，而合成的构造方法中的形式参数后填充到proxies中，所以后填充的同名符号在前，通过shadowed指向先添加的符号。 

调用initOuterThis\(\)方法创建封装类的实例变量的初始化语句所对应的语法树，initOuterThis\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
JCStatement initOuterThis(_) {
    VarSymbol rhs = outerThisStack.head;
    Assert.check(rhs.owner.kind == MTH);
    VarSymbol lhs = outerThisStack.tail.head;
    Assert.check(rhs.owner.owner == lhs.owner);
    return
        make.Exec(
            make.Assign(
                make.Select(make.This(lhs.owner.erasure(types)), lhs),
                make.Ident(rhs)).setType(lhs.erasure(types)));
}
```

---

从outerThisStack中取出构造方法合成的形式参数对应的VarSymbol对象，然后取出封闭类的实例对应的成员变量的VarSymbol对象进行赋值操作。 

**3．更新本地类中引用自由变量的方式，替换为引用合成的成员变量**

调用Lower类的visitIdent\(\)方法更新本地类中引用自由变量的方式，替换为引用合成的成员变量，例如实例15\-26的Local类中，x1与x2变量对a与b自由变量的引用更新为对val与val$b成员变量的引用。 

visitIdent\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
public void visitIdent(JCIdent tree) {
    result = access(tree.sym, tree, _, _);
}
```

---

调用的access\(\)方法的实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
JCExpression access(Symbol sym, JCExpression tree, _, _) {
    while (sym.kind == VAR && 
        sym.owner.kind == MTH && 
        sym.owner.enclClass() != currentClass) {
 // 条件判断保存引用的是自由变量
        // 当cv不等于null时，表示是字面量值，直接将引用的自由变量替换为对应的字面量值
        Object cv = ((VarSymbol)sym).getConstValue();
        if (cv != null) {
            return makeLit(sym.type, cv);
        }
        // 引用的自由变量更新为引用自由变量对应合成的成员变量，所以从proxies中查找
        sym = proxies.lookup(proxyName(sym.name)).sym;
        Assert.check(sym != null && (sym.flags_field & FINAL) != 0);
        tree = make.Ident(sym);
    }
    ...
    return tree;
}
```

---

access\(\)方法中有许多关于内部类语法糖的逻辑，在第15.4.2节介绍的为成员添加获取方法就是在这个方法中实现的，不过这里只关注如何获取合成的成员变量。 

**4．更新对本地类构造方法的调用，主要是在创建本地类的对象时，为构造方法传递实际参数**

如果通过对象创建表达式创建已经更新了构造方法的类时，需要调用Lower类的visitNewClass\(\)方法对对象创建表达式进行更新，这个方法的相关实现代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
ClassSymbol c = (ClassSymbol)tree.constructor.owner;
// 如果c.owner为本地类，为对象创建表达式追加参数，也就是自由变量
if ((c.owner.kind & (VAR | MTH)) != 0) {
    tree.args = tree.args.appendList(loadFreevars(_, freevars(c)));
}
// 如果cs有封闭类实例，为对象创建表达式追加参数，也就是封闭类的实例
if (cs.hasOuterInstance()) {
    JCExpression thisArg;
    if ((cs.owner.kind & (MTH16 | VAR04)) != 0) { 
        TypeSymbol ts = cs.type.getEnclosingType().tsym;
        thisArg = makeThis( ts);
    } 
    tree.args = tree.args.prepend(thisArg);
}
```

---

在调用构造方法时传递封闭类的实例和自由变量，调用makeThis\(\)方法合成外部类的实例对应的语法树，然后将这个语法树追加到实际参数列表的头部，调用loadFreevars\(\)方法得到自由变量对应的语法树并追加到实际参数列表的末尾，这与更新构造方法时添加的形式参数的顺序一致。 

调用的loadFreevars\(\)方法的实代码如下： 

---

```java
来源：com.sun.tools.javac.comp.Lower
List<JCExpression> loadFreevars(_, List<VarSymbol> freevars) {
     List<JCExpression> args = List.nil();
     for (List<VarSymbol> l = freevars; l.nonEmpty(); l = l.tail)
         args = args.prepend(loadFreevar(_, l.head));
     return args;
}
JCExpression loadFreevar(_, VarSymbol v) {
     return access(v, make.Ident(v), _, _);
}
```

---

同样会调用access\(\)方法，不过这次通常会直接返回make.Ident\(v\)方法创建的语法树节点。对于实例15\-26来说，最终将JCIdent\(name=a\)与JCIdent\(name=b\)按顺序追加到实际参数列表的末尾。 

另外，在构造方法中通过this\(...\)或super\(...\)形式的语句也会调用更新过的构造方法，所以也需要更新这些形式的语句。更新的过程与visitNewClass\(\)方法中的实现类似，这里不再介绍，有兴趣的读者可以查阅Lower类的visitApply\(\)方法了解相关的实现过程。 
